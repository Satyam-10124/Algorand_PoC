#!/usr/bin/env python3
# app.py - Flask API for the compliance document system

from flask import Flask, request, jsonify, render_template
from Compliance.document_compliance_client import ComplianceClient
from algosdk.v2client import algod
from algosdk import account, mnemonic
from algosdk.v2client import indexer
import os
import hashlib
import datetime
import json

app = Flask(__name__, 
    static_folder='frontend/build/static',
    template_folder='frontend/build')

# Configuration
# Replace these with your Algorand node details
algod_address = "http://localhost:4001"
algod_token = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

# Initialize Algod client
algod_client = algod.AlgodClient(algod_token, algod_address)

# Initialize Indexer client for TestNet - we'll use this for account info
indexer_address = "https://testnet-idx.algonode.cloud"
indexer_token = ""
indexer_client = indexer.IndexerClient(indexer_token, indexer_address)

# Load admin/verifier accounts from config
try:
    with open(os.path.join(os.path.dirname(os.path.abspath(__file__)), "Compliance/compliance_test_accounts.json")) as f:
        admin_verifier_accounts = json.load(f)
    admin_private_key = admin_verifier_accounts.get('admin', {}).get('private_key', '')
    verifier_private_key = admin_verifier_accounts.get('verifier', {}).get('private_key', '')
    verifier_address = admin_verifier_accounts.get('verifier', {}).get('address', '')
    admin_address = admin_verifier_accounts.get('admin', {}).get('address', '')
    # Get App ID - in a production environment you would store this in a config file
    # For now we'll hardcode the App ID for the existing deployed contract
    APP_ID = 744059516  # Replace with your actual deployed app ID
except Exception as e:
    print(f"Error loading accounts: {str(e)}")
    admin_private_key = ""
    verifier_private_key = ""
    verifier_address = ""
    admin_address = ""
    APP_ID = None

# Utility function to generate document hash
def generate_document_hash(content):
    """Generate SHA-256 hash of document content"""
    return hashlib.sha256(content.encode()).hexdigest()

# Routes for the API - focus on document handling and verification
@app.route('/api/document/hash', methods=['POST'])
def get_document_hash():
    """Get hash for a document without uploading to blockchain"""
    try:
        data = request.json
        document_content = data.get('document_content')
        
        if not document_content:
            return jsonify({"success": False, "error": "Document content is required"}), 400
            
        # Generate hash
        doc_hash = generate_document_hash(document_content)
        
        return jsonify({
            "success": True, 
            "document_hash": doc_hash,
            "timestamp": datetime.datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
        
@app.route('/api/upload', methods=['POST'])
def upload_document():
    """Handle document upload and generate hash"""
    try:
        # Check if file was uploaded
        if 'file' not in request.files:
            return jsonify({"success": False, "error": "No file uploaded"}), 400
            
        file = request.files['file']
        if file.filename == '':
            return jsonify({"success": False, "error": "No file selected"}), 400
        
        # Read file content
        content = file.read().decode('utf-8', errors='ignore')
        
        # Generate hash
        doc_hash = generate_document_hash(content)
        
        return jsonify({
            "success": True,
            "hash": doc_hash,
            "filename": file.filename,
            "timestamp": datetime.datetime.now().isoformat()
        })
    except Exception as e:
        print(f"Error uploading document: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/document/register', methods=['POST'])
def register_document():
    """Register a document with the compliance contract - ADMIN ONLY"""
    try:
        data = request.json
        verifier_role = data.get('role')
        provided_key = data.get('private_key')
        document_content = data.get('document_content')
        version = data.get('version')
        
        # Only allow admin to register documents
        if verifier_role != 'admin' or provided_key != admin_private_key:
            return jsonify({"success": False, "error": "Unauthorized: Only admin can register documents"}), 403
            
        if not APP_ID:
            return jsonify({"success": False, "error": "No deployed app ID found"}), 400
        
        # Initialize client
        client = ComplianceClient(algod_client, admin_private_key)
        
        # Register document
        client.register_document(APP_ID, document_content, version)
        
        # Generate hash for reference
        doc_hash = generate_document_hash(document_content)
        
        return jsonify({
            "success": True,
            "document_hash": doc_hash
        })
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/verifier/assign', methods=['POST'])
def assign_verifier():
    """Assign a verifier to the compliance contract - ADMIN ONLY"""
    try:
        data = request.json
        verifier_role = data.get('role')
        provided_key = data.get('private_key')
        new_verifier_address = data.get('verifier_address')
        
        # Only allow admin to assign verifiers
        if verifier_role != 'admin' or provided_key != admin_private_key:
            return jsonify({"success": False, "error": "Unauthorized: Only admin can assign verifiers"}), 403
            
        if not APP_ID:
            return jsonify({"success": False, "error": "No deployed app ID found"}), 400
        
        # Initialize client
        client = ComplianceClient(algod_client, admin_private_key)
        
        # Assign verifier
        client.assign_verifier(APP_ID, new_verifier_address)
        
        return jsonify({
            "success": True,
            "message": f"Assigned {new_verifier_address} as verifier"
        })
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/document/verify', methods=['POST'])
def verify_compliance():
    """Verify compliance of a document - VERIFIER ONLY"""
    try:
        data = request.json
        verifier_role = data.get('role')
        provided_key = data.get('private_key')
        document_hash = data.get('document_hash')
        
        # Only allow verifier to verify compliance
        if verifier_role != 'verifier' or provided_key != verifier_private_key:
            return jsonify({"success": False, "error": "Unauthorized: Only designated verifiers can verify compliance"}), 403
            
        if not APP_ID:
            return jsonify({"success": False, "error": "No deployed app ID found"}), 400
        
        # Initialize client
        client = ComplianceClient(algod_client, verifier_private_key)
        
        # Verify compliance
        client.verify_compliance(APP_ID)
        
        # Get updated status
        status = client.get_compliance_status(APP_ID)
        
        return jsonify({
            "success": True,
            "verified_hash": document_hash,
            "status": status.get('status', 'Unknown'),
            "verification_date": datetime.datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/document/status', methods=['GET'])
def get_compliance_status():
    """Get compliance status of the document - Public endpoint"""
    try:
        if not APP_ID:
            return jsonify({"success": False, "error": "No deployed app ID found"}), 400
            
        # Use admin key for read-only operations
        # In production, use a dedicated read-only account
        client = ComplianceClient(algod_client, admin_private_key)
        
        # Get compliance status
        status = client.get_compliance_status(APP_ID)
        
        # Convert timestamp to human-readable format if available
        if status.get('attestation_date'):
            status['attestation_date_readable'] = datetime.datetime.fromtimestamp(
                status['attestation_date']).strftime('%Y-%m-%d %H:%M:%S')
        
        if status.get('expiration_date'):
            status['expiration_date_readable'] = datetime.datetime.fromtimestamp(
                status['expiration_date']).strftime('%Y-%m-%d %H:%M:%S')
            
            # Add days until expiration
            now = datetime.datetime.now().timestamp()
            if now < status['expiration_date']:
                days_remaining = (status['expiration_date'] - now) / (60 * 60 * 24)
                status['days_until_expiration'] = int(days_remaining)
            else:
                status['days_until_expiration'] = 0
        
        return jsonify({"success": True, "status": status})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
        
@app.route('/api/login/verifier', methods=['POST'])
def verifier_login():
    """Login as a verifier"""
    try:
        data = request.json
        provided_key = data.get('private_key')
        
        # Check if this is a valid verifier
        if provided_key == verifier_private_key:
            address = verifier_address
            role = 'verifier'
        elif provided_key == admin_private_key:
            address = admin_address
            role = 'admin'
        else:
            return jsonify({"success": False, "error": "Invalid credentials"}), 401
            
        return jsonify({
            "success": True,
            "address": address,
            "role": role
        })
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/account/status', methods=['GET'])
def account_status():
    """Check if an account is a verifier and if it's opted in to the compliance contract"""
    try:
        address = request.args.get('address')
        if not address:
            return jsonify({"success": False, "error": "Address parameter is required"}), 400
            
        # Check if this is a verifier or admin account
        is_verifier = (address == verifier_address)
        is_admin = (address == admin_address)
        
        # Get account information from indexer
        account_info = indexer_client.account_info(address)
        
        # Check if account is opted into the app
        is_opted_in = False
        local_state = None
        
        if 'account' in account_info and 'apps-local-state' in account_info['account']:
            for app_state in account_info['account']['apps-local-state']:
                if app_state['id'] == APP_ID:
                    is_opted_in = True
                    local_state = app_state.get('key-value', [])
                    break
                    
        return jsonify({
            "success": True, 
            "address": address,
            "is_verifier": is_verifier,
            "is_admin": is_admin,
            "is_opted_in": is_opted_in,
            "account_info": account_info.get('account', {}),
            "local_state": local_state
        })
    except Exception as e:
        print(f"Error checking account status: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

# Serve React frontend
@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def serve(path):
    return render_template('index.html')

if __name__ == '__main__':
    app.run(debug=True, port=5044)
